diff -urN a/gst/isomp4/qtdemux.c b/gst/isomp4/qtdemux.c
--- a/gst/isomp4/qtdemux.c	2013-05-08 21:02:30.000000000 +0200
+++ b/gst/isomp4/qtdemux.c	2013-05-09 15:23:51.506458561 +0200
@@ -212,6 +212,9 @@
   /* track id */
   guint track_id;
 
+  /* description index */
+  guint description_idx;
+
   /* duration/scale */
   guint64 duration;             /* in timescale */
   guint32 timescale;
@@ -344,6 +347,15 @@
   guint32 def_sample_duration;
   guint32 def_sample_size;
   guint32 def_sample_flags;
+  guint32 def_sample_description_idx;
+
+  /* FIXME in case of a 'cenc' based encryption
+   * we need this struct, maybe this should be
+   * an union between all different encryption
+   * types?
+   */
+  gboolean encrypted;
+  guint32 senc_sample_index;
 };
 
 enum QtDemuxState
@@ -354,12 +366,24 @@
   QTDEMUX_STATE_BUFFER_MDAT     /* Buffering the mdat atom */
 };
 
+enum
+{
+  SIGNAL_CENC_TENC,
+  SIGNAL_CENC_SENC,
+  SIGNAL_PSSH,
+  SIGNAL_DECRYPT,
+  LAST_SIGNAL
+};
+
+static guint qtdemux_signals[LAST_SIGNAL] = { 0 };
+
 static GNode *qtdemux_tree_get_child_by_type (GNode * node, guint32 fourcc);
 static GNode *qtdemux_tree_get_child_by_type_full (GNode * node,
     guint32 fourcc, GstByteReader * parser);
 static GNode *qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc);
 static GNode *qtdemux_tree_get_sibling_by_type_full (GNode * node,
     guint32 fourcc, GstByteReader * parser);
+static GNode *qtdemux_tree_get_parent_by_type (GNode * node, guint32 fourcc);
 
 static GstStaticPadTemplate gst_qtdemux_sink_template =
     GST_STATIC_PAD_TEMPLATE ("sink",
@@ -370,19 +394,19 @@
     );
 
 static GstStaticPadTemplate gst_qtdemux_videosrc_template =
-GST_STATIC_PAD_TEMPLATE ("video_%02d",
+GST_STATIC_PAD_TEMPLATE ("video_%02d_%02d",
     GST_PAD_SRC,
     GST_PAD_SOMETIMES,
     GST_STATIC_CAPS_ANY);
 
 static GstStaticPadTemplate gst_qtdemux_audiosrc_template =
-GST_STATIC_PAD_TEMPLATE ("audio_%02d",
+GST_STATIC_PAD_TEMPLATE ("audio_%02d_%02d",
     GST_PAD_SRC,
     GST_PAD_SOMETIMES,
     GST_STATIC_CAPS_ANY);
 
 static GstStaticPadTemplate gst_qtdemux_subsrc_template =
-GST_STATIC_PAD_TEMPLATE ("subtitle_%02d",
+GST_STATIC_PAD_TEMPLATE ("subtitle_%02d_%02d",
     GST_PAD_SRC,
     GST_PAD_SOMETIMES,
     GST_STATIC_CAPS_ANY);
@@ -432,6 +456,103 @@
 static GstFlowReturn qtdemux_expose_streams (GstQTDemux * qtdemux);
 
 static void
+g_cclosure_marshal_BUFFER__UINT_BUFFER_UINT (GClosure * closure,
+    GValue * return_value,
+    guint n_param_values,
+    const GValue * param_values,
+    gpointer invocation_hint G_GNUC_UNUSED, gpointer marshal_data)
+{
+  typedef gpointer (*GMarshalFunc_BUFFER__UINT_BUFFER_UINT) (gpointer data1,
+      guint arg_1, gpointer arg_2, guint arg_3, gpointer data2);
+  register GMarshalFunc_BUFFER__UINT_BUFFER_UINT callback;
+  register GCClosure *cc = (GCClosure *) closure;
+  register gpointer data1, data2;
+  gpointer v_return;
+
+  g_return_if_fail (return_value != NULL);
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure)) {
+    data1 = closure->data;
+    data2 = g_value_peek_pointer (param_values + 0);
+  } else {
+    data1 = g_value_peek_pointer (param_values + 0);
+    data2 = closure->data;
+  }
+
+
+  callback =
+      (GMarshalFunc_BUFFER__UINT_BUFFER_UINT) (marshal_data ? marshal_data :
+      cc->callback);
+
+  v_return = callback (data1,
+      g_value_get_uint (param_values + 1),
+      g_value_peek_pointer (param_values + 2),
+      g_value_get_uint (param_values + 3), data2);
+
+  gst_value_take_buffer (return_value, v_return);
+}
+
+static void
+g_cclosure_marshal_VOID__UINT_BUFFER (GClosure * closure,
+    GValue * return_value G_GNUC_UNUSED,
+    guint n_param_values,
+    const GValue * param_values,
+    gpointer invocation_hint G_GNUC_UNUSED, gpointer marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__UINT_BUFFER) (gpointer data1, guint arg_1,
+      gpointer arg_2, gpointer data2);
+  register GMarshalFunc_VOID__UINT_BUFFER callback;
+  register GCClosure *cc = (GCClosure *) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure)) {
+    data1 = closure->data;
+    data2 = g_value_peek_pointer (param_values + 0);
+  } else {
+    data1 = g_value_peek_pointer (param_values + 0);
+    data2 = closure->data;
+  }
+  callback =
+      (GMarshalFunc_VOID__UINT_BUFFER) (marshal_data ? marshal_data :
+      cc->callback);
+
+  callback (data1,
+      g_value_get_uint (param_values + 1),
+      g_value_peek_pointer (param_values + 2), data2);
+}
+
+static void
+g_cclosure_marshal_VOID__BUFFER (GClosure * closure,
+    GValue * return_value G_GNUC_UNUSED,
+    guint n_param_values,
+    const GValue * param_values,
+    gpointer invocation_hint G_GNUC_UNUSED, gpointer marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__BUFFER) (gpointer data1,
+      gpointer arg_2, gpointer data2);
+  register GMarshalFunc_VOID__BUFFER callback;
+  register GCClosure *cc = (GCClosure *) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 2);
+
+  if (G_CCLOSURE_SWAP_DATA (closure)) {
+    data1 = closure->data;
+    data2 = g_value_peek_pointer (param_values + 0);
+  } else {
+    data1 = g_value_peek_pointer (param_values + 0);
+    data2 = closure->data;
+  }
+  callback =
+      (GMarshalFunc_VOID__BUFFER) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1, g_value_peek_pointer (param_values + 1), data2);
+}
+
+static void
 gst_qtdemux_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
@@ -471,6 +592,31 @@
   gstelement_class->get_index = GST_DEBUG_FUNCPTR (gst_qtdemux_get_index);
 
   gst_tag_register_musicbrainz_tags ();
+
+  /* Register signals */
+  qtdemux_signals[SIGNAL_DECRYPT] =
+      g_signal_new ("decrypt", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstQTDemuxClass, decrypt),
+      NULL, NULL,
+      g_cclosure_marshal_BUFFER__UINT_BUFFER_UINT, GST_TYPE_BUFFER, 3,
+      G_TYPE_UINT, GST_TYPE_BUFFER, G_TYPE_UINT);
+  qtdemux_signals[SIGNAL_PSSH] =
+      g_signal_new ("pssh", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstQTDemuxClass, pssh),
+      NULL, NULL,
+      g_cclosure_marshal_VOID__BUFFER, G_TYPE_NONE, 1, GST_TYPE_BUFFER);
+  qtdemux_signals[SIGNAL_CENC_TENC] =
+      g_signal_new ("cenc-tenc", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstQTDemuxClass, cenc_tenc),
+      NULL, NULL,
+      g_cclosure_marshal_VOID__UINT_BUFFER, G_TYPE_NONE, 2,
+      G_TYPE_UINT, GST_TYPE_BUFFER);
+  qtdemux_signals[SIGNAL_CENC_SENC] =
+      g_signal_new ("cenc-senc", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstQTDemuxClass, cenc_senc),
+      NULL, NULL,
+      g_cclosure_marshal_VOID__UINT_BUFFER, G_TYPE_NONE, 2,
+      G_TYPE_UINT, GST_TYPE_BUFFER);
 }
 
 static void
@@ -834,6 +980,7 @@
 gst_qtdemux_push_pending_newsegment (GstQTDemux * qtdemux)
 {
   if (qtdemux->pending_newsegment) {
+    GST_DEBUG_OBJECT (qtdemux, "pushing pending newsegment");
     gst_qtdemux_push_event (qtdemux, qtdemux->pending_newsegment);
     qtdemux->pending_newsegment = NULL;
   }
@@ -1817,6 +1964,36 @@
   g_free (stream);
 }
 
+static void
+gst_qtdemux_cleanup (GstQTDemux * qtdemux)
+{
+  gint n;
+
+  qtdemux->mdatoffset = GST_CLOCK_TIME_NONE;
+  if (qtdemux->mdatbuffer)
+    gst_buffer_unref (qtdemux->mdatbuffer);
+  qtdemux->mdatbuffer = NULL;
+  if (qtdemux->tag_list)
+    gst_tag_list_free (qtdemux->tag_list);
+  qtdemux->tag_list = NULL;
+  if (qtdemux->element_index)
+    gst_object_unref (qtdemux->element_index);
+  qtdemux->element_index = NULL;
+  for (n = 0; n < qtdemux->n_streams; n++) {
+    gst_qtdemux_stream_free (qtdemux, qtdemux->streams[n]);
+    qtdemux->streams[n] = NULL;
+  }
+  qtdemux->n_streams = 0;
+  qtdemux->n_video_streams = 0;
+  qtdemux->n_audio_streams = 0;
+  qtdemux->n_sub_streams = 0;
+  gst_segment_init (&qtdemux->segment, GST_FORMAT_TIME);
+  qtdemux->requested_seek_time = GST_CLOCK_TIME_NONE;
+  qtdemux->seek_offset = 0;
+  qtdemux->upstream_seekable = FALSE;
+  qtdemux->upstream_size = 0;
+}
+
 static GstStateChangeReturn
 gst_qtdemux_change_state (GstElement * element, GstStateChange transition)
 {
@@ -1833,9 +2010,7 @@
   result = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
 
   switch (transition) {
-    case GST_STATE_CHANGE_PAUSED_TO_READY:{
-      gint n;
-
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
       qtdemux->state = QTDEMUX_STATE_INITIAL;
       qtdemux->neededbytes = 16;
       qtdemux->todrop = 0;
@@ -1845,36 +2020,13 @@
       qtdemux->first_mdat = -1;
       qtdemux->header_size = 0;
       qtdemux->got_moov = FALSE;
-      qtdemux->mdatoffset = GST_CLOCK_TIME_NONE;
-      if (qtdemux->mdatbuffer)
-        gst_buffer_unref (qtdemux->mdatbuffer);
-      qtdemux->mdatbuffer = NULL;
+      gst_adapter_clear (qtdemux->adapter);
+      gst_qtdemux_cleanup (qtdemux);
+      qtdemux->major_brand = 0;
       if (qtdemux->comp_brands)
         gst_buffer_unref (qtdemux->comp_brands);
       qtdemux->comp_brands = NULL;
-      if (qtdemux->tag_list)
-        gst_tag_list_free (qtdemux->tag_list);
-      qtdemux->tag_list = NULL;
-      if (qtdemux->element_index)
-        gst_object_unref (qtdemux->element_index);
-      qtdemux->element_index = NULL;
-      gst_adapter_clear (qtdemux->adapter);
-      for (n = 0; n < qtdemux->n_streams; n++) {
-        gst_qtdemux_stream_free (qtdemux, qtdemux->streams[n]);
-        qtdemux->streams[n] = NULL;
-      }
-      qtdemux->major_brand = 0;
-      qtdemux->n_streams = 0;
-      qtdemux->n_video_streams = 0;
-      qtdemux->n_audio_streams = 0;
-      qtdemux->n_sub_streams = 0;
-      gst_segment_init (&qtdemux->segment, GST_FORMAT_TIME);
-      qtdemux->requested_seek_time = GST_CLOCK_TIME_NONE;
-      qtdemux->seek_offset = 0;
-      qtdemux->upstream_seekable = FALSE;
-      qtdemux->upstream_size = 0;
       break;
-    }
     default:
       break;
   }
@@ -2032,10 +2184,17 @@
 }
 
 static gboolean
-qtdemux_parse_trex (GstQTDemux * qtdemux, QtDemuxStream * stream,
-    guint32 * ds_duration, guint32 * ds_size, guint32 * ds_flags)
-{
-  if (!stream->parsed_trex && qtdemux->moov_node) {
+qtdemux_parse_trex (GstQTDemux * qtdemux, guint track_id,
+    guint32 * ds_duration, guint32 * ds_size, guint32 * ds_flags,
+    guint32 * ds_description_idx)
+{
+  guint32 def_sample_duration = 0;
+  guint32 def_sample_size = 0;
+  guint32 def_sample_flags = 0;
+  guint32 def_sample_description_idx = 1;
+  gboolean parsed_trex = FALSE;
+
+  if (qtdemux->moov_node) {
     GNode *mvex, *trex;
     GstByteReader trex_data;
 
@@ -2044,17 +2203,16 @@
       trex = qtdemux_tree_get_child_by_type_full (mvex, FOURCC_trex,
           &trex_data);
       while (trex) {
-        guint32 id = 0, dur = 0, size = 0, flags = 0;
+        guint32 id = 0, dur = 0, size = 0, flags = 0, didx = 0;
 
         /* skip version/flags */
         if (!gst_byte_reader_skip (&trex_data, 4))
           goto next;
         if (!gst_byte_reader_get_uint32_be (&trex_data, &id))
           goto next;
-        if (id != stream->track_id)
+        if (id != track_id)
           goto next;
-        /* sample description index; ignore */
-        if (!gst_byte_reader_get_uint32_be (&trex_data, &dur))
+        if (!gst_byte_reader_get_uint32_be (&trex_data, &didx))
           goto next;
         if (!gst_byte_reader_get_uint32_be (&trex_data, &dur))
           goto next;
@@ -2063,14 +2221,16 @@
         if (!gst_byte_reader_get_uint32_be (&trex_data, &flags))
           goto next;
 
-        GST_DEBUG_OBJECT (qtdemux, "fragment defaults for stream %d; "
-            "duration %d,  size %d, flags 0x%x", stream->track_id,
-            dur, size, flags);
-
-        stream->parsed_trex = TRUE;
-        stream->def_sample_duration = dur;
-        stream->def_sample_size = size;
-        stream->def_sample_flags = flags;
+        GST_DEBUG_OBJECT (qtdemux, "fragment defaults for track %d; "
+            "description idx %d, duration %d,  size %d, flags 0x%x",
+            track_id, didx, dur, size, flags);
+
+        parsed_trex = TRUE;
+        def_sample_duration = dur;
+        def_sample_size = size;
+        def_sample_flags = flags;
+        def_sample_description_idx = didx;
+        break;
 
       next:
         /* iterate all siblings */
@@ -2080,14 +2240,14 @@
     }
   }
 
-  *ds_duration = stream->def_sample_duration;
-  *ds_size = stream->def_sample_size;
-  *ds_size = stream->def_sample_size;
-
+  *ds_duration = def_sample_duration;
+  *ds_size = def_sample_size;
+  *ds_flags = def_sample_flags;
+  *ds_description_idx = def_sample_description_idx;
   /* even then, above values are better than random ... */
-  if (G_UNLIKELY (!stream->parsed_trex)) {
+  if (G_UNLIKELY (!parsed_trex)) {
     GST_WARNING_OBJECT (qtdemux,
-        "failed to find fragment defaults for stream %d", stream->track_id);
+        "failed to find fragment defaults for track %d", track_id);
     return FALSE;
   }
 
@@ -2098,7 +2258,7 @@
 qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
     QtDemuxStream * stream, guint32 d_sample_duration, guint32 d_sample_size,
     guint32 d_sample_flags, gint64 moof_offset, gint64 moof_length,
-    gint64 * base_offset, gint64 * running_offset)
+    gint64 * base_offset, gint64 * running_offset, gint64 base_decode_time)
 {
   guint64 timestamp;
   gint32 data_offset = 0;
@@ -2109,10 +2269,10 @@
   QtDemuxSample *sample;
   gboolean ismv = FALSE;
 
-  GST_LOG_OBJECT (qtdemux, "parsing trun stream %d; "
-      "default dur %d, size %d, flags 0x%x, base offset %" G_GINT64_FORMAT,
-      stream->track_id, d_sample_duration, d_sample_size, d_sample_flags,
-      *base_offset);
+  GST_LOG_OBJECT (qtdemux, "parsing trun track %d; "
+      "stream %d, default dur %d, size %d, flags 0x%x, base offset %"
+      G_GINT64_FORMAT, stream->track_id, stream->description_idx,
+      d_sample_duration, d_sample_size, d_sample_flags, *base_offset);
 
   /* presence of stss or not can't really tell us much,
    * and flags and so on tend to be marginally reliable in these files */
@@ -2139,6 +2299,8 @@
       GST_LOG_OBJECT (qtdemux, "base_offset at moof");
       *base_offset = moof_offset;
     }
+    if (data_offset < moof_length + 8)
+      data_offset = moof_length + 8;
     *running_offset = *base_offset + data_offset;
   } else {
     /* if no offset at all, that would mean data starts at moof start,
@@ -2220,7 +2382,7 @@
   if (G_UNLIKELY (stream->n_samples == 0)) {
     /* the timestamp of the first sample is also provided by the tfra entry
      * but we shouldn't rely on it as it is at the end of files */
-    timestamp = 0;
+    timestamp = base_decode_time;
   } else {
     /* subsequent fragments extend stream */
     timestamp =
@@ -2299,9 +2461,9 @@
   }
 }
 
-/* find stream with @id */
+/* find stream with @id and description index @idx */
 static inline QtDemuxStream *
-qtdemux_find_stream (GstQTDemux * qtdemux, guint32 id)
+qtdemux_find_stream (GstQTDemux * qtdemux, guint32 id, guint32 idx)
 {
   QtDemuxStream *stream;
   gint i;
@@ -2315,25 +2477,95 @@
   /* try to get it fast and simple */
   if (G_LIKELY (id <= qtdemux->n_streams)) {
     stream = qtdemux->streams[id - 1];
-    if (G_LIKELY (stream->track_id == id))
+    if (G_LIKELY ((stream->track_id == id) && (stream->description_idx == idx)))
       return stream;
   }
 
   /* linear search otherwise */
   for (i = 0; i < qtdemux->n_streams; i++) {
     stream = qtdemux->streams[i];
-    if (stream->track_id == id)
+    if ((stream->track_id == id) && (stream->description_idx == idx))
       return stream;
   }
 
+  GST_ERROR_OBJECT (qtdemux,
+      "Impossible to find the stream for track id %d and description idx %d",
+      id, idx);
+
   return NULL;
 }
 
+static inline gboolean
+qtdemux_check_brand (GstQTDemux * qtdemux, guint32 fourcc, gboolean major)
+{
+  if (major) {
+    return (qtdemux->major_brand == fourcc);
+  } else if (qtdemux->comp_brands != NULL) {
+    guint8 *data = GST_BUFFER_DATA (qtdemux->comp_brands);
+    guint size = GST_BUFFER_SIZE (qtdemux->comp_brands);
+    gboolean res = FALSE;
+
+    while (size >= 4) {
+      res = res || (QT_FOURCC (data) == fourcc);
+      data += 4;
+      size -= 4;
+    }
+    return res;
+  } else {
+    return FALSE;
+  }
+}
+
+static inline gboolean
+qtdemux_is_brand_piff (GstQTDemux * qtdemux, gboolean major)
+{
+  return qtdemux_check_brand (qtdemux, GST_MAKE_FOURCC ('p', 'i', 'f', 'f'),
+      major);
+}
+
+static inline gboolean
+qtdemux_is_brand_iso5 (GstQTDemux * qtdemux, gboolean major)
+{
+  return qtdemux_check_brand (qtdemux, GST_MAKE_FOURCC ('i', 's', 'o', '5'),
+      major);
+}
+
+static inline void
+qtdemux_get_track_defaults (GstQTDemux * qtdemux, guint track_id,
+    guint32 * ds_duration, guint32 * ds_size, guint32 * ds_flags,
+    guint32 * ds_description_idx)
+{
+  gint i;
+
+  /* check */
+  if (G_UNLIKELY (!track_id)) {
+    GST_DEBUG_OBJECT (qtdemux, "invalid track id 0");
+    return;
+  }
+
+  /* get the first stream and check if it is alread parsed */
+  for (i = 0; i < qtdemux->n_streams; i++) {
+    QtDemuxStream *stream;
+
+    stream = qtdemux->streams[i];
+    if ((stream->track_id == track_id) && (stream->parsed_trex)) {
+      *ds_duration = stream->def_sample_duration;
+      *ds_size = stream->def_sample_size;
+      *ds_flags = stream->def_sample_flags;
+      *ds_description_idx = stream->def_sample_description_idx;
+      return;
+    }
+  }
+
+  GST_WARNING_OBJECT (qtdemux, "Impossible to find the track id %d", track_id);
+}
+
+
 static gboolean
 qtdemux_parse_tfhd (GstQTDemux * qtdemux, GstByteReader * tfhd,
     QtDemuxStream ** stream, guint32 * default_sample_duration,
     guint32 * default_sample_size, guint32 * default_sample_flags,
-    gint64 * base_offset)
+    guint32 * default_sample_description_idx, gint64 * base_offset)
 {
   guint32 flags = 0;
   guint32 track_id = 0;
@@ -2345,7 +2577,23 @@
   if (!gst_byte_reader_get_uint32_be (tfhd, &track_id))
     goto invalid_track;
 
-  *stream = qtdemux_find_stream (qtdemux, track_id);
+  /* obtain stream defaults */
+  if (!qtdemux_parse_trex (qtdemux, track_id,
+          default_sample_duration, default_sample_size, default_sample_flags,
+          default_sample_description_idx)) {
+    GST_LOG_OBJECT (qtdemux, "check if the default values are already parsed");
+    /* or it is not found, or the trex was already parsed */
+    qtdemux_get_track_defaults (qtdemux, track_id,
+        default_sample_duration, default_sample_size, default_sample_flags,
+        default_sample_description_idx);
+  }
+
+  if (flags & TF_SAMPLE_DESCRIPTION_INDEX)
+    if (!gst_byte_reader_get_uint32_be (tfhd, default_sample_description_idx))
+      goto invalid_track;
+
+  *stream = qtdemux_find_stream (qtdemux, track_id,
+      *default_sample_description_idx);
   if (G_UNLIKELY (!*stream))
     goto unknown_stream;
 
@@ -2353,15 +2601,6 @@
     if (!gst_byte_reader_get_uint64_be (tfhd, (guint64 *) base_offset))
       goto invalid_track;
 
-  /* obtain stream defaults */
-  qtdemux_parse_trex (qtdemux, *stream,
-      default_sample_duration, default_sample_size, default_sample_flags);
-
-  /* FIXME: Handle TF_SAMPLE_DESCRIPTION_INDEX properly */
-  if (flags & TF_SAMPLE_DESCRIPTION_INDEX)
-    if (!gst_byte_reader_skip (tfhd, 4))
-      goto invalid_track;
-
   if (flags & TF_DEFAULT_SAMPLE_DURATION)
     if (!gst_byte_reader_get_uint32_be (tfhd, default_sample_duration))
       goto invalid_track;
@@ -2374,6 +2613,12 @@
     if (!gst_byte_reader_get_uint32_be (tfhd, default_sample_flags))
       goto invalid_track;
 
+  /* in case the iso5 flag is set, reset the base offset */
+  if (qtdemux_is_brand_iso5 (qtdemux, FALSE)) {
+    if (flags & TF_DEFAULT_BASE_IS_MOOF)
+      *base_offset = -1;
+  }
+
   return TRUE;
 
 invalid_track:
@@ -2395,7 +2640,7 @@
   guint32 version = 0;
 
   if (!gst_byte_reader_get_uint32_be (br, &version))
-    return FALSE;
+    goto failed;
 
   version >>= 24;
   if (version == 1) {
@@ -2426,8 +2671,9 @@
 {
   GNode *moof_node, *traf_node, *tfhd_node, *trun_node, *tfdt_node;
   GstByteReader trun_data, tfhd_data, tfdt_data;
-  guint32 ds_size = 0, ds_duration = 0, ds_flags = 0;
+  guint32 ds_size = 0, ds_duration = 0, ds_flags = 0, ds_description_idx = 0;
   gint64 base_offset, running_offset;
+  guint64 decode_time = 0;
 
   /* NOTE @stream ignored */
 
@@ -2439,6 +2685,8 @@
   base_offset = running_offset = -1;
   traf_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_traf);
   while (traf_node) {
+    GNode *senc_node;
+
     /* Fragment Header node */
     tfhd_node =
         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_tfhd,
@@ -2446,21 +2694,31 @@
     if (!tfhd_node)
       goto missing_tfhd;
     if (!qtdemux_parse_tfhd (qtdemux, &tfhd_data, &stream, &ds_duration,
-            &ds_size, &ds_flags, &base_offset))
+            &ds_size, &ds_flags, &ds_description_idx, &base_offset))
       goto missing_tfhd;
     tfdt_node =
         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_tfdt,
         &tfdt_data);
     if (tfdt_node) {
-      guint64 decode_time = 0;
       qtdemux_parse_tfdt (qtdemux, &tfdt_data, &decode_time);
-      /* If there is a new segment pending, update the time/position */
+      /* If there is a new segment pending, update the start */
       if (qtdemux->pending_newsegment) {
+        GstFormat format;
+        gboolean update;
+        gdouble rate;
+        gint64 start, stop, time, start_offset;
+
+        gst_event_parse_new_segment (qtdemux->pending_newsegment, &update,
+            &rate, &format, &start, &stop, &time);
+
+        start_offset =
+            gst_util_uint64_scale (decode_time, GST_SECOND, stream->timescale);
+
+        GST_DEBUG_OBJECT (qtdemux, "updating newsegment start with %"
+            GST_TIME_FORMAT " (tfdt)", GST_TIME_ARGS (start + start_offset));
         gst_event_replace (&qtdemux->pending_newsegment,
-            gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME,
-                0, GST_CLOCK_TIME_NONE,
-                gst_util_uint64_scale (decode_time,
-                    GST_SECOND, stream->timescale)));
+            gst_event_new_new_segment (update, rate, format,
+                start + start_offset, stop, time));
         /* ref added when replaced, release the original _new one */
         gst_event_unref (qtdemux->pending_newsegment);
       }
@@ -2472,6 +2730,29 @@
       base_offset = -2;
       goto next;
     }
+
+    /* TODO we might have the saiz and saio boxes */
+    if (stream->encrypted) {
+      GstBuffer *senc = NULL;
+      /* check if the brand has piff, if so, find the uuid */
+      if (qtdemux_is_brand_piff (qtdemux, FALSE)) {
+        /* TODO double check the extension */
+        senc_node = qtdemux_tree_get_child_by_type (traf_node, FOURCC_uuid);
+      } else
+        senc_node = qtdemux_tree_get_child_by_type (traf_node, FOURCC_senc);
+      if (senc_node) {
+        senc = gst_buffer_new ();
+        GST_BUFFER_DATA (senc) = senc_node->data;
+        GST_BUFFER_SIZE (senc) = GST_READ_UINT32_BE (senc_node->data);
+      }
+      g_signal_emit (qtdemux, qtdemux_signals[SIGNAL_CENC_SENC], 0,
+          stream->track_id, senc);
+
+      if (senc)
+        gst_buffer_unref (senc);
+      stream->senc_sample_index = 0;
+    }
+
     if (G_UNLIKELY (base_offset < -1))
       goto lost_offset;
     /* Track Run node */
@@ -2481,7 +2762,7 @@
     while (trun_node) {
       qtdemux_parse_trun (qtdemux, &trun_data, stream,
           ds_duration, ds_size, ds_flags, moof_offset, length, &base_offset,
-          &running_offset);
+          &running_offset, decode_time);
       /* iterate all siblings */
       trun_node = qtdemux_tree_get_sibling_by_type_full (trun_node, FOURCC_trun,
           &trun_data);
@@ -3403,7 +3684,8 @@
     GST_LOG_OBJECT (demux, "current position: %" GST_TIME_FORMAT
         ", stream end: %" GST_TIME_FORMAT,
         GST_TIME_ARGS (demux->segment.last_stop), GST_TIME_ARGS (end_time));
-    if (end_time + 2 * GST_SECOND < demux->segment.last_stop) {
+    if (GST_CLOCK_TIME_IS_VALID (end_time) &&
+        (end_time + 2 * GST_SECOND < demux->segment.last_stop)) {
       GST_DEBUG_OBJECT (demux, "sending EOS for stream %s",
           GST_PAD_NAME (stream->pad));
       stream->sent_eos = TRUE;
@@ -3633,6 +3915,21 @@
 {
   GstFlowReturn ret = GST_FLOW_OK;
 
+  if (G_UNLIKELY (stream->encrypted)) {
+    GstBuffer *dec_buf = NULL;
+
+    GST_DEBUG_OBJECT (qtdemux, "decrypting stream index = %d track index %d",
+        stream->senc_sample_index, stream->track_id);
+    /* send the decrypt signal */
+    g_signal_emit (qtdemux, qtdemux_signals[SIGNAL_DECRYPT], 0,
+        stream->track_id, buf, stream->senc_sample_index++, &dec_buf);
+
+    if (dec_buf) {
+      gst_buffer_unref (buf);
+      buf = dec_buf;
+    }
+  }
+
   if (G_UNLIKELY (stream->fourcc == FOURCC_rtsp)) {
     gchar *url;
 
@@ -4224,32 +4521,28 @@
         extract_initial_length_and_fourcc (data, demux->neededbytes, NULL,
             &fourcc);
         if (fourcc == FOURCC_moov) {
-          /* in usual fragmented setup we could try to scan for more
-           * and end up at the the moov (after mdat) again */
-          if (demux->got_moov && demux->n_streams > 0) {
-            GST_DEBUG_OBJECT (demux,
-                "Skipping moov atom as we have one already");
-          } else {
-            GST_DEBUG_OBJECT (demux, "Parsing [moov]");
+          GST_DEBUG_OBJECT (demux, "Parsing [moov]");
 
-            demux->got_moov = TRUE;
+          if (demux->got_moov) {
+            gst_qtdemux_cleanup (demux);
+          }
 
-            /* prepare newsegment to send when streaming actually starts */
-            if (!demux->pending_newsegment) {
-              demux->pending_newsegment =
-                  gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME,
-                  0, GST_CLOCK_TIME_NONE, 0);
-            }
+          demux->got_moov = TRUE;
 
-            qtdemux_parse_moov (demux, data, demux->neededbytes);
-            qtdemux_node_dump (demux, demux->moov_node);
-            qtdemux_parse_tree (demux);
-            qtdemux_expose_streams (demux);
-
-            g_node_destroy (demux->moov_node);
-            demux->moov_node = NULL;
-            GST_DEBUG_OBJECT (demux, "Finished parsing the header");
+          /* prepare newsegment to send when streaming actually starts */
+          if (!demux->pending_newsegment) {
+            demux->pending_newsegment =
+                gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME,
+                0, GST_CLOCK_TIME_NONE, 0);
           }
+
+          qtdemux_parse_moov (demux, data, demux->neededbytes);
+          qtdemux_node_dump (demux, demux->moov_node);
+          qtdemux_parse_tree (demux);
+
+          g_node_destroy (demux->moov_node);
+          demux->moov_node = NULL;
+          GST_DEBUG_OBJECT (demux, "Finished parsing the header");
         } else if (fourcc == FOURCC_moof) {
           if (demux->got_moov && demux->fragmented) {
             GST_DEBUG_OBJECT (demux, "Parsing [moof]");
@@ -4383,8 +4676,14 @@
         /* initial newsegment sent here after having added pads,
          * possible others in sink_event */
         if (G_UNLIKELY (demux->pending_newsegment)) {
-          gst_qtdemux_push_event (demux, demux->pending_newsegment);
-          demux->pending_newsegment = NULL;
+          /* first expose the streams, this is done here because the
+           * pads need to be created after the first mdat is received
+           * this ensure that the described streams actually have samples
+           * or either from the stbl (static) atom or the trun (fragmented)
+           * atom
+           */
+          qtdemux_expose_streams (demux);
+          gst_qtdemux_push_pending_newsegment (demux);
           /* clear to send tags on all streams */
           for (i = 0; i < demux->n_streams; i++) {
             gst_qtdemux_push_tags (demux, demux->streams[i]);
@@ -4581,9 +4880,23 @@
 #endif /* HAVE_ZLIB */
 
 static gboolean
+qtdemux_parse_pssh (GstQTDemux * qtdemux, GNode * pssh)
+{
+  GstBuffer *buf;
+
+  /* for the pssh, just send the buffer completely */
+  buf = gst_buffer_new ();
+  GST_BUFFER_DATA (buf) = pssh->data;
+  g_signal_emit (qtdemux, qtdemux_signals[SIGNAL_PSSH], 0, buf);
+  gst_buffer_unref (buf);
+  return TRUE;
+}
+
+static gboolean
 qtdemux_parse_moov (GstQTDemux * qtdemux, const guint8 * buffer, guint length)
 {
   GNode *cmov;
+  GNode *pssh;
 
   qtdemux->moov_node = g_node_new ((guint8 *) buffer);
 
@@ -4593,6 +4906,11 @@
   GST_DEBUG_OBJECT (qtdemux, "parsing 'moov' atom");
   qtdemux_parse_node (qtdemux, qtdemux->moov_node, buffer, length);
 
+  pssh = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_pssh);
+  if (pssh) {
+    qtdemux_parse_pssh (qtdemux, pssh);
+  }
+
   cmov = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_cmov);
   if (cmov) {
     guint32 method;
@@ -4789,6 +5107,7 @@
         qtdemux_parse_container (qtdemux, node, buffer + 16, end);
         break;
       }
+      case FOURCC_enca:
       case FOURCC_mp4a:
       case FOURCC_alac:
       {
@@ -4883,6 +5202,7 @@
         }
         break;
       }
+      case FOURCC_encv:
       case FOURCC_avc1:
       {
         GST_MEMDUMP_OBJECT (qtdemux, "avc1", buffer, end - buffer);
@@ -5035,6 +5355,25 @@
   return qtdemux_tree_get_sibling_by_type_full (node, fourcc, NULL);
 }
 
+static GNode *
+qtdemux_tree_get_parent_by_type (GNode * node, guint32 fourcc)
+{
+  GNode *parent;
+  guint8 *buffer;
+  guint32 parent_fourcc;
+
+  for (parent = node->parent; parent; parent = parent->parent) {
+    buffer = (guint8 *) parent->data;
+
+    parent_fourcc = QT_FOURCC (buffer + 4);
+
+    if (G_UNLIKELY (parent_fourcc == fourcc)) {
+      return parent;
+    }
+  }
+  return NULL;
+}
+
 static gboolean
 gst_qtdemux_add_stream (GstQTDemux * qtdemux,
     QtDemuxStream * stream, GstTagList * list)
@@ -5045,7 +5384,8 @@
       0, GST_CLOCK_TIME_NONE, 0);
 
   if (stream->subtype == FOURCC_vide) {
-    gchar *name = g_strdup_printf ("video_%02d", qtdemux->n_video_streams);
+    gchar *name = g_strdup_printf ("video_%02d_%02d", stream->track_id,
+        stream->description_idx);
 
     stream->pad =
         gst_pad_new_from_static_template (&gst_qtdemux_videosrc_template, name);
@@ -5163,7 +5503,8 @@
     }
     qtdemux->n_video_streams++;
   } else if (stream->subtype == FOURCC_soun) {
-    gchar *name = g_strdup_printf ("audio_%02d", qtdemux->n_audio_streams);
+    gchar *name = g_strdup_printf ("audio_%02d_%02d", stream->track_id,
+        stream->description_idx);
 
     stream->pad =
         gst_pad_new_from_static_template (&gst_qtdemux_audiosrc_template, name);
@@ -5177,7 +5518,8 @@
   } else if (stream->subtype == FOURCC_strm) {
     GST_DEBUG_OBJECT (qtdemux, "stream type, not creating pad");
   } else if (stream->subtype == FOURCC_subp || stream->subtype == FOURCC_text) {
-    gchar *name = g_strdup_printf ("subtitle_%02d", qtdemux->n_sub_streams);
+    gchar *name = g_strdup_printf ("subtitle_%02d_%02d", stream->track_id,
+        stream->description_idx);
 
     stream->pad =
         gst_pad_new_from_static_template (&gst_qtdemux_subsrc_template, name);
@@ -5569,8 +5911,9 @@
   guint32 n_samples_per_chunk;
   guint32 n_samples;
 
-  GST_LOG_OBJECT (qtdemux, "parsing samples for stream fourcc %"
-      GST_FOURCC_FORMAT ", pad %s", GST_FOURCC_ARGS (stream->fourcc),
+  GST_LOG_OBJECT (qtdemux, "parsing samples for stream at track %d, idx %d, "
+      "fourcc %" GST_FOURCC_FORMAT ", pad %s", stream->track_id,
+      stream->description_idx, GST_FOURCC_ARGS (stream->fourcc),
       stream->pad ? GST_PAD_NAME (stream->pad) : "(NULL)");
 
   n_samples = stream->n_samples;
@@ -6105,13 +6448,11 @@
  * the SMI and gama atoms.
  */
 static void
-qtdemux_parse_svq3_stsd_data (GstQTDemux * qtdemux, GNode * stsd,
-    guint8 ** gamma, GstBuffer ** seqh)
+qtdemux_parse_svq3_stsd_data (GstQTDemux * qtdemux, const guint8 * stsd_data,
+    guint32 length, const guint8 ** gamma, GstBuffer ** seqh)
 {
-  guint8 *_gamma = NULL;
+  const guint8 *_gamma = NULL;
   GstBuffer *_seqh = NULL;
-  guint8 *stsd_data = stsd->data;
-  guint32 length = QT_UINT32 (stsd_data);
   guint16 version;
 
   if (length < 32) {
@@ -6128,7 +6469,7 @@
       stsd_data += 70;
       while (length > 8) {
         guint32 fourcc, size;
-        guint8 *data;
+        const guint8 *data;
         size = QT_UINT32 (stsd_data);
         fourcc = QT_FOURCC (stsd_data + 4);
         data = stsd_data + 8;
@@ -6345,191 +6686,179 @@
   return 0;
 }
 
-/* parse the traks.
- * With each track we associate a new QtDemuxStream that contains all the info
- * about the trak.
- * traks that do not decode to something (like strm traks) will not have a pad.
- */
+/* called whenever the scheme is cenc */
 static gboolean
-qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
+qtdemux_parse_cenc (GstQTDemux * qtdemux, QtDemuxStream * stream,
+    guint32 scheme_version, GNode * schi)
 {
-  GstByteReader tkhd;
-  int offset;
-  GNode *mdia;
-  GNode *mdhd;
-  GNode *hdlr;
-  GNode *minf;
-  GNode *stbl;
-  GNode *stsd;
-  GNode *mp4a;
-  GNode *mp4v;
-  GNode *wave;
-  GNode *esds;
-  GNode *pasp;
-  QtDemuxStream *stream;
-  GstTagList *list = NULL;
-  gchar *codec = NULL;
-  const guint8 *stsd_data;
-  guint16 lang_code;            /* quicktime lang code or packed iso code */
-  guint32 version;
-  guint32 tkhd_flags = 0;
-  guint8 tkhd_version = 0;
-  guint32 fourcc;
-  guint value_size, len;
+  GNode *tenc;
+  GstBuffer *buf;
 
-  stream = g_new0 (QtDemuxStream, 1);
-  /* new streams always need a discont */
-  stream->discont = TRUE;
-  /* we enable clipping for raw audio/video streams */
-  stream->need_clip = FALSE;
-  stream->need_process = FALSE;
-  stream->segment_index = -1;
-  stream->time_position = 0;
-  stream->sample_index = -1;
-  stream->last_ret = GST_FLOW_OK;
+  /* For piff based brands, the scheme version is 0x00010001 */
+  if ((scheme_version != 0x00010000) && (scheme_version != 0x00010001)) {
+    GST_WARNING_OBJECT (qtdemux, "Wrong version number %08x", scheme_version);
+    return FALSE;
+  }
 
-  if (!qtdemux_tree_get_child_by_type_full (trak, FOURCC_tkhd, &tkhd)
-      || !gst_byte_reader_get_uint8 (&tkhd, &tkhd_version)
-      || !gst_byte_reader_get_uint24_be (&tkhd, &tkhd_flags))
-    goto corrupt_file;
+  /* get the 'tenc' box from the 'schi' */
+  if (!(tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_tenc))) {
+    GST_WARNING_OBJECT (qtdemux, "No tenc found");
+    return FALSE;
+  }
 
-  /* pick between 64 or 32 bits */
-  value_size = tkhd_version == 1 ? 8 : 4;
-  if (!gst_byte_reader_skip (&tkhd, value_size * 2) ||
-      !gst_byte_reader_get_uint32_be (&tkhd, &stream->track_id))
-    goto corrupt_file;
+  buf = gst_buffer_new ();
+  GST_BUFFER_DATA (buf) = tenc->data;
+  g_signal_emit (qtdemux, qtdemux_signals[SIGNAL_CENC_TENC], 0,
+      stream->track_id, buf);
+  gst_buffer_unref (buf);
 
-  GST_LOG_OBJECT (qtdemux, "track[tkhd] version/flags/id: 0x%02x/%06x/%u",
-      tkhd_version, tkhd_flags, stream->track_id);
+  return TRUE;
+}
 
-  if (!(mdia = qtdemux_tree_get_child_by_type (trak, FOURCC_mdia)))
-    goto corrupt_file;
+static void
+qtdemux_parse_schm (GstQTDemux * qtdemux, GNode * schm, guint32 * scheme_type,
+    guint32 * scheme_version)
+{
+  guint32 flags;
+  guint32 length;
+  const gchar *schm_data;
 
-  if (!(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mdhd))) {
-    /* be nice for some crooked mjp2 files that use mhdr for mdhd */
-    if (qtdemux->major_brand != FOURCC_mjp2 ||
-        !(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mhdr)))
-      goto corrupt_file;
-  }
+  schm_data = (const gchar *) schm->data;
 
-  len = QT_UINT32 ((guint8 *) mdhd->data);
-  version = QT_UINT32 ((guint8 *) mdhd->data + 8);
-  GST_LOG_OBJECT (qtdemux, "track version/flags: %08x", version);
-  if (version == 0x01000000) {
-    if (len < 38)
-      goto corrupt_file;
-    stream->timescale = QT_UINT32 ((guint8 *) mdhd->data + 28);
-    stream->duration = QT_UINT64 ((guint8 *) mdhd->data + 32);
-    lang_code = QT_UINT16 ((guint8 *) mdhd->data + 36);
-  } else {
-    if (len < 30)
-      goto corrupt_file;
-    stream->timescale = QT_UINT32 ((guint8 *) mdhd->data + 20);
-    stream->duration = QT_UINT32 ((guint8 *) mdhd->data + 24);
-    lang_code = QT_UINT16 ((guint8 *) mdhd->data + 28);
+  length = QT_UINT32 (schm_data);
+  flags = QT_UINT24 (schm_data + 8);
+
+  *scheme_type = QT_FOURCC (schm_data + 12);
+  *scheme_version = QT_UINT32 (schm_data + 16);
+
+  GST_LOG_OBJECT (qtdemux, "schm type %" GST_FOURCC_FORMAT,
+      GST_FOURCC_ARGS (*scheme_type));
+  GST_LOG_OBJECT (qtdemux, "schm version %u", *scheme_version);
+
+  if ((flags & QT_FLAG_CONTAINER) && (length > 20)) {
+    GST_LOG_OBJECT (qtdemux, "schm uri %.*s", length - 20, schm_data + 20);
   }
+}
 
-  if (lang_code < 0x800) {
-    qtdemux_lang_map_qt_code_to_iso (stream->lang_id, lang_code);
-  } else {
-    stream->lang_id[0] = 0x60 + ((lang_code >> 10) & 0x1F);
-    stream->lang_id[1] = 0x60 + ((lang_code >> 5) & 0x1F);
-    stream->lang_id[2] = 0x60 + (lang_code & 0x1F);
-    stream->lang_id[3] = 0;
+static gboolean
+qtdemux_parse_sinf (GstQTDemux * qtdemux, QtDemuxStream * stream,
+    GNode * sinf, guint32 * fourcc)
+{
+  GNode *frma;
+  GNode *schm;
+  GNode *schi;
+  const guint8 *frma_data;
+  gboolean ret = TRUE;
+  guint32 scheme_type;
+  guint32 scheme_version;
+
+  /* now the 'frma' */
+  if (!(frma = qtdemux_tree_get_child_by_type (sinf, FOURCC_frma))) {
+    GST_WARNING_OBJECT (qtdemux, "No frma found");
+    return FALSE;
   }
 
-  GST_LOG_OBJECT (qtdemux, "track timescale: %" G_GUINT32_FORMAT,
-      stream->timescale);
-  GST_LOG_OBJECT (qtdemux, "track duration: %" G_GUINT64_FORMAT,
-      stream->duration);
-  GST_LOG_OBJECT (qtdemux, "track language code/id: 0x%04x/%s",
-      lang_code, stream->lang_id);
+  frma_data = (const guint8 *) frma->data;
+  *fourcc = QT_FOURCC (frma_data + 8);
 
-  if (G_UNLIKELY (stream->timescale == 0 || qtdemux->timescale == 0))
-    goto corrupt_file;
+  /* get the scheme type box */
+  if (!(schm = qtdemux_tree_get_child_by_type (sinf, FOURCC_schm))) {
+    GST_WARNING_OBJECT (qtdemux, "No schm found");
+    return FALSE;
+  }
 
-  /* fragmented files may have bogus duration in moov */
-  if (!qtdemux->fragmented &&
-      qtdemux->duration != G_MAXINT64 && stream->duration != G_MAXINT32) {
-    guint64 tdur1, tdur2;
+  qtdemux_parse_schm (qtdemux, schm, &scheme_type, &scheme_version);
 
-    /* don't overflow */
-    tdur1 = stream->timescale * (guint64) qtdemux->duration;
-    tdur2 = qtdemux->timescale * (guint64) stream->duration;
+  /* get the scheme information box */
+  if (!(schi = qtdemux_tree_get_child_by_type (sinf, FOURCC_schi))) {
+    GST_WARNING_OBJECT (qtdemux, "No schi found");
+    return FALSE;
+  }
 
-    /* HACK:
-     * some of those trailers, nowadays, have prologue images that are
-     * themselves vide tracks as well. I haven't really found a way to
-     * identify those yet, except for just looking at their duration. */
-    if (tdur1 != 0 && (tdur2 * 10 / tdur1) < 2) {
+  /* parse the data on this box */
+  switch (scheme_type) {
+    case FOURCC_cenc:
+      ret = qtdemux_parse_cenc (qtdemux, stream, scheme_version, schi);
+      break;
+      /* TODO so far every file that has a piff also has a cenc with the info
+       * duplicated, so we dont need to parse it again
+       */
+    case FOURCC_piff:
+      break;
+
+    default:
       GST_WARNING_OBJECT (qtdemux,
-          "Track shorter than 20%% (%" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT
-          " vs. %" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT ") of the stream "
-          "found, assuming preview image or something; skipping track",
-          stream->duration, stream->timescale, qtdemux->duration,
-          qtdemux->timescale);
-      g_free (stream);
-      return TRUE;
-    }
+          "Unsupported scheme type %" GST_FOURCC_FORMAT,
+          GST_FOURCC_ARGS (scheme_type));
+      return FALSE;
   }
 
-  if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
-    goto corrupt_file;
-
-  GST_LOG_OBJECT (qtdemux, "track type: %" GST_FOURCC_FORMAT,
-      GST_FOURCC_ARGS (QT_FOURCC ((guint8 *) hdlr->data + 12)));
-
-  len = QT_UINT32 ((guint8 *) hdlr->data);
-  if (len >= 20)
-    stream->subtype = QT_FOURCC ((guint8 *) hdlr->data + 16);
-  GST_LOG_OBJECT (qtdemux, "track subtype: %" GST_FOURCC_FORMAT,
-      GST_FOURCC_ARGS (stream->subtype));
-
-  if (!(minf = qtdemux_tree_get_child_by_type (mdia, FOURCC_minf)))
-    goto corrupt_file;
+  return ret;
+}
 
-  if (!(stbl = qtdemux_tree_get_child_by_type (minf, FOURCC_stbl)))
-    goto corrupt_file;
+static gboolean
+qtdemux_parse_encx (GstQTDemux * qtdemux, QtDemuxStream * stream,
+    GNode * encx, guint32 * fourcc)
+{
+  GNode *sinf;
 
-  /* parse stsd */
-  if (!(stsd = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsd)))
-    goto corrupt_file;
-  stsd_data = (const guint8 *) stsd->data;
+  /* now the 'sinf' */
+  sinf = qtdemux_tree_get_child_by_type (encx, FOURCC_sinf);
+  if (!sinf) {
+    GST_WARNING_OBJECT (qtdemux, "No sinf found");
+    return FALSE;
+  }
 
-  /* stsd should at least have one entry */
-  len = QT_UINT32 (stsd_data);
-  if (len < 24)
-    goto corrupt_file;
+  while (sinf) {
+    if (!qtdemux_parse_sinf (qtdemux, stream, sinf, fourcc))
+      return FALSE;
+    sinf = qtdemux_tree_get_sibling_by_type (sinf, FOURCC_sinf);
+  }
 
-  /* and that entry should fit within stsd */
-  len = QT_UINT32 (stsd_data + 16);
-  if (len > QT_UINT32 (stsd_data) + 16)
-    goto corrupt_file;
-  GST_LOG_OBJECT (qtdemux, "stsd len:           %d", len);
+  return TRUE;
+}
 
-  stream->fourcc = fourcc = QT_FOURCC (stsd_data + 16 + 4);
-  GST_LOG_OBJECT (qtdemux, "stsd type:          %" GST_FOURCC_FORMAT,
-      GST_FOURCC_ARGS (stream->fourcc));
+/* NOTE: this function receives the stsd_data starting at the entry
+ * not starting at the stsd atom, so this differs from old code
+ * not every offset has bene confirmed yet
+ */
+static gboolean
+qtdemux_parse_stsd_entry (GstQTDemux * qtdemux, const guint8 * stsd_data,
+    guint len, GNode * fourcc_node, guint32 fourcc, QtDemuxStream * stream)
+{
+  GstTagList *list = NULL;
+  GNode *mp4a;
+  GNode *mp4v;
+  GNode *wave;
+  GNode *esds;
+  GNode *pasp;
+  GNode *stbl;
+  GNode *trak;
+  gchar *codec = NULL;
+  int offset;
 
-  if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi) ||
-      ((fourcc & 0xFFFFFF00) == GST_MAKE_FOURCC ('e', 'n', 'c', 0)))
+  if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi))
     goto error_encrypted;
 
-  if (stream->subtype == FOURCC_vide) {
-    guint32 w = 0, h = 0;
-
-    stream->sampled = TRUE;
+  /* get the real fourcc */
+  if ((fourcc == FOURCC_encv) || (fourcc == FOURCC_enca)) {
+    GNode *encx;
 
-    /* version 1 uses some 64-bit ints */
-    if (!gst_byte_reader_skip (&tkhd, 56 + value_size)
-        || !gst_byte_reader_get_uint32_be (&tkhd, &w)
-        || !gst_byte_reader_get_uint32_be (&tkhd, &h))
+    encx = fourcc_node;
+    if (!encx)
+      goto corrupt_file;
+    if (!qtdemux_parse_encx (qtdemux, stream, encx, &(stream->fourcc)))
       goto corrupt_file;
 
-    stream->display_width = w >> 16;
-    stream->display_height = h >> 16;
+    stream->encrypted = TRUE;
+    GST_LOG_OBJECT (qtdemux, "track decrypted format %" GST_FOURCC_FORMAT,
+        GST_FOURCC_ARGS (stream->fourcc));
+  } else {
+    stream->fourcc = fourcc;
+  }
 
-    offset = 16;
+  if (stream->subtype == FOURCC_vide) {
+    offset = 0;
     if (len < 86)
       goto corrupt_file;
 
@@ -6544,7 +6873,7 @@
         QT_UINT16 (stsd_data + offset + 48));
 
     stream->caps =
-        qtdemux_video_caps (qtdemux, stream, fourcc, stsd_data, &codec);
+        qtdemux_video_caps (qtdemux, stream, stream->fourcc, stsd_data, &codec);
     if (codec) {
       list = gst_tag_list_new ();
       gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
@@ -6556,7 +6885,7 @@
     esds = NULL;
     pasp = NULL;
     /* pick 'the' stsd child */
-    mp4v = qtdemux_tree_get_child_by_type (stsd, fourcc);
+    mp4v = fourcc_node;
     if (mp4v) {
       esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);
       pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);
@@ -6575,11 +6904,12 @@
     if (esds) {
       gst_qtdemux_handle_esds (qtdemux, stream, esds, list);
     } else {
-      switch (fourcc) {
+      switch (stream->fourcc) {
         case FOURCC_avc1:
         {
-          gint len = QT_UINT32 (stsd_data) - 0x66;
-          const guint8 *avc_data = stsd_data + 0x66;
+          /* old 0x66, i.e 16 less */
+          gint len = QT_UINT32 (stsd_data) - 0x56;
+          const guint8 *avc_data = stsd_data + 0x56;
 
           /* find avcC */
           while (len >= 0x8) {
@@ -6672,7 +7002,7 @@
           GNode *glbl;
 
           GST_DEBUG_OBJECT (qtdemux, "found %" GST_FOURCC_FORMAT,
-              GST_FOURCC_ARGS (fourcc));
+              GST_FOURCC_ARGS (stream->fourcc));
 
           /* codec data might be in glbl extension atom */
           glbl = mp4v ?
@@ -6710,7 +7040,7 @@
 
           GST_DEBUG_OBJECT (qtdemux, "found mjp2");
           /* some required atoms */
-          mjp2 = qtdemux_tree_get_child_by_type (stsd, FOURCC_mjp2);
+          mjp2 = fourcc_node;
           if (!mjp2)
             break;
           jp2h = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2h);
@@ -6884,10 +7214,11 @@
         {
           GstBuffer *buf;
           GstBuffer *seqh = NULL;
-          guint8 *gamma_data = NULL;
+          const guint8 *gamma_data = NULL;
           gint len = QT_UINT32 (stsd_data);
 
-          qtdemux_parse_svq3_stsd_data (qtdemux, stsd, &gamma_data, &seqh);
+          qtdemux_parse_svq3_stsd_data (qtdemux, stsd_data, len, &gamma_data,
+              &seqh);
           if (gamma_data) {
             gst_caps_set_simple (stream->caps, "applied-gamma", G_TYPE_DOUBLE,
                 QT_FP32 (gamma_data), NULL);
@@ -6918,7 +7249,7 @@
           GNode *xith, *xdxt;
 
           GST_DEBUG_OBJECT (qtdemux, "found XiTh");
-          xith = qtdemux_tree_get_child_by_type (stsd, FOURCC_XiTh);
+          xith = fourcc_node;
           if (!xith)
             break;
 
@@ -6940,7 +7271,7 @@
           GstBuffer *buf;
 
           GST_DEBUG_OBJECT (qtdemux, "parse ovc1 header");
-          ovc1 = qtdemux_tree_get_child_by_type (stsd, FOURCC_ovc1);
+          ovc1 = fourcc_node;
           if (!ovc1)
             break;
           ovc1_data = ovc1->data;
@@ -6963,14 +7294,14 @@
 
     GST_INFO_OBJECT (qtdemux,
         "type %" GST_FOURCC_FORMAT " caps %" GST_PTR_FORMAT,
-        GST_FOURCC_ARGS (fourcc), stream->caps);
+        GST_FOURCC_ARGS (stream->fourcc), stream->caps);
 
   } else if (stream->subtype == FOURCC_soun) {
     int version, samplesize;
     guint16 compression_id;
     gboolean amrwb = FALSE;
 
-    offset = 32;
+    offset = 16;
     if (len < 36)
       goto corrupt_file;
 
@@ -7001,7 +7332,7 @@
     stream->bytes_per_packet = stream->bytes_per_sample;
 
     offset = 52;
-    switch (fourcc) {
+    switch (stream->fourcc) {
         /* Yes, these have to be hard-coded */
       case FOURCC_MAC6:
       {
@@ -7054,7 +7385,7 @@
     }
 
     if (version == 0x00010000) {
-      switch (fourcc) {
+      switch (stream->fourcc) {
         case FOURCC_twos:
         case FOURCC_sowt:
         case FOURCC_raw_:
@@ -7106,17 +7437,16 @@
       GST_WARNING_OBJECT (qtdemux, "unknown version %08x", version);
     }
 
-    stream->caps = qtdemux_audio_caps (qtdemux, stream, fourcc, NULL, 0,
+    stream->caps = qtdemux_audio_caps (qtdemux, stream, stream->fourcc, NULL, 0,
         &codec);
 
-    switch (fourcc) {
+    switch (stream->fourcc) {
       case FOURCC_in24:
       {
         GNode *enda;
         GNode *in24;
 
-        in24 = qtdemux_tree_get_child_by_type (stsd, FOURCC_in24);
-
+        in24 = fourcc_node;
         enda = qtdemux_tree_get_child_by_type (in24, FOURCC_enda);
         if (!enda) {
           wave = qtdemux_tree_get_child_by_type (in24, FOURCC_wave);
@@ -7152,7 +7482,7 @@
         WAVEFORMATEX *wfex;
 
         GST_DEBUG_OBJECT (qtdemux, "parse owma");
-        owma = qtdemux_tree_get_child_by_type (stsd, FOURCC_owma);
+        owma = fourcc_node;
         if (!owma)
           break;
         owma_data = owma->data;
@@ -7215,7 +7545,7 @@
             bitrate, NULL);
     }
 
-    mp4a = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4a);
+    mp4a = fourcc_node;
     wave = NULL;
     esds = NULL;
     if (mp4a) {
@@ -7234,7 +7564,7 @@
        codec id as the bottom 16 bits - but byte-swapped to store in QT (which
        is big-endian).
      */
-    if ((fourcc & 0xffff) == (('s' << 8) | 'm')) {
+    if ((stream->fourcc & 0xffff) == (('s' << 8) | 'm')) {
       if (len < offset + 20) {
         GST_WARNING_OBJECT (qtdemux, "No wave atom in MS-style audio");
       } else {
@@ -7248,7 +7578,8 @@
           const guint8 *waveheader;
           guint32 headerlen;
 
-          waveheadernode = qtdemux_tree_get_child_by_type (wavenode, fourcc);
+          waveheadernode =
+              qtdemux_tree_get_child_by_type (wavenode, stream->fourcc);
           if (waveheadernode) {
             waveheader = (const guint8 *) waveheadernode->data;
             headerlen = QT_UINT32 (waveheader);
@@ -7284,7 +7615,7 @@
     } else if (esds) {
       gst_qtdemux_handle_esds (qtdemux, stream, esds, list);
     } else {
-      switch (fourcc) {
+      switch (stream->fourcc) {
 #if 0
           /* FIXME: what is in the chunk? */
         case FOURCC_QDMC:
@@ -7317,7 +7648,7 @@
 
           /* apparently, m4a has this atom appended directly in the stsd entry,
            * while mov has it in a wave atom */
-          alac = qtdemux_tree_get_child_by_type (stsd, FOURCC_alac);
+          alac = fourcc_node;
           if (alac) {
             /* alac now refers to stsd entry atom */
             wave = qtdemux_tree_get_child_by_type (alac, FOURCC_wave);
@@ -7382,14 +7713,17 @@
     }
     GST_INFO_OBJECT (qtdemux,
         "type %" GST_FOURCC_FORMAT " caps %" GST_PTR_FORMAT,
-        GST_FOURCC_ARGS (fourcc), stream->caps);
+        GST_FOURCC_ARGS (stream->fourcc), stream->caps);
 
   } else if (stream->subtype == FOURCC_strm) {
-    if (fourcc == FOURCC_rtsp) {
+    GNode *minf;
+
+    minf = qtdemux_tree_get_parent_by_type (fourcc_node, FOURCC_minf);
+    if (stream->fourcc == FOURCC_rtsp) {
       stream->redirect_uri = qtdemux_get_rtsp_uri_from_hndl (qtdemux, minf);
     } else {
       GST_INFO_OBJECT (qtdemux, "unhandled stream type %" GST_FOURCC_FORMAT,
-          GST_FOURCC_ARGS (fourcc));
+          GST_FOURCC_ARGS (stream->fourcc));
       goto unknown_stream;
     }
     stream->sampled = TRUE;
@@ -7397,10 +7731,10 @@
 
     stream->sampled = TRUE;
 
-    offset = 16;
+    offset = 0;
 
     stream->caps =
-        qtdemux_sub_caps (qtdemux, stream, fourcc, stsd_data, &codec);
+        qtdemux_sub_caps (qtdemux, stream, stream->fourcc, stsd_data, &codec);
     if (codec) {
       list = gst_tag_list_new ();
       gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
@@ -7410,7 +7744,7 @@
     }
 
     /* hunt for sort-of codec data */
-    switch (fourcc) {
+    switch (stream->fourcc) {
       case FOURCC_mp4s:
       {
         guint len;
@@ -7477,13 +7811,14 @@
     stream->sampled = TRUE;
   }
 
+  stbl = qtdemux_tree_get_parent_by_type (fourcc_node, FOURCC_stbl);
   /* collect sample information */
   if (!qtdemux_stbl_init (qtdemux, stream, stbl))
     goto samples_failed;
 
   if (qtdemux->fragmented) {
-    guint32 dummy;
     guint64 offset;
+    guint32 ds_size = 0, ds_duration = 0, ds_flags = 0, ds_description_idx = 0;
 
     /* need all moov samples as basis; probably not many if any at all */
     /* prevent moof parsing taking of at this time */
@@ -7501,10 +7836,18 @@
       stream->duration = gst_util_uint64_scale (qtdemux->segment.duration,
           stream->timescale, GST_SECOND);
     /* need defaults for fragments */
-    qtdemux_parse_trex (qtdemux, stream, &dummy, &dummy, &dummy);
+    if (qtdemux_parse_trex (qtdemux, stream->track_id, &ds_duration, &ds_size,
+            &ds_flags, &ds_description_idx)) {
+      stream->def_sample_duration = ds_duration;
+      stream->def_sample_size = ds_size;
+      stream->def_sample_flags = ds_flags;
+      stream->def_sample_description_idx = ds_description_idx;
+      stream->parsed_trex = TRUE;
+    }
   }
 
   /* configure segments */
+  trak = qtdemux_tree_get_parent_by_type (fourcc_node, FOURCC_trak);
   if (!qtdemux_parse_segments (qtdemux, stream, trak))
     goto segments_failed;
 
@@ -7522,29 +7865,19 @@
         GST_TAG_LANGUAGE_CODE, (lang_code) ? lang_code : stream->lang_id, NULL);
   }
 
-  /* now we are ready to add the stream */
-  if (qtdemux->n_streams >= GST_QTDEMUX_MAX_STREAMS)
-    goto too_many_streams;
-
   stream->pending_tags = list;
-  qtdemux->streams[qtdemux->n_streams] = stream;
-  qtdemux->n_streams++;
-  GST_DEBUG_OBJECT (qtdemux, "n_streams is now %d", qtdemux->n_streams);
 
   return TRUE;
-
 /* ERRORS */
 corrupt_file:
   {
     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
         (_("This file is corrupt and cannot be played.")), (NULL));
-    g_free (stream);
     return FALSE;
   }
 error_encrypted:
   {
     GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT, (NULL), (NULL));
-    g_free (stream);
     return FALSE;
   }
 samples_failed:
@@ -7553,15 +7886,102 @@
     /* we posted an error already */
     /* free stbl sub-atoms */
     gst_qtdemux_stbl_free (stream);
-    g_free (stream);
     return FALSE;
   }
 unknown_stream:
   {
     GST_INFO_OBJECT (qtdemux, "unknown subtype %" GST_FOURCC_FORMAT,
         GST_FOURCC_ARGS (stream->subtype));
-    g_free (stream);
-    return TRUE;
+    return FALSE;
+  }
+}
+
+static gboolean
+qtdemux_parse_stsd (GstQTDemux * qtdemux, GNode * stsd,
+    const QtDemuxStream * trackinfo)
+{
+  GNode *fourcc_node = NULL;
+  const guint8 *stsd_data;
+  guint32 num_entries;
+  guint len;
+  gint i;
+
+  stsd_data = (const guint8 *) stsd->data;
+
+  /* stsd should at least have one entry */
+  len = QT_UINT32 (stsd_data);
+  if (len < 24)
+    goto corrupt_file;
+
+  num_entries = QT_UINT32 (stsd_data + 12);
+
+  stsd_data += 16;
+  len -= 16;
+
+  for (i = 0; i < num_entries; i++) {
+    QtDemuxStream *stream;
+    guint entry_len;
+    guint32 fourcc;
+
+    /* check if can add a new stream */
+    if (qtdemux->n_streams >= GST_QTDEMUX_MAX_STREAMS)
+      goto too_many_streams;
+
+    /* and that entry should fit within stsd */
+    entry_len = QT_UINT32 (stsd_data);
+    if (entry_len > len)
+      goto corrupt_file;
+
+    GST_LOG_OBJECT (qtdemux, "stsd len:           %d", entry_len);
+    fourcc = QT_FOURCC (stsd_data + 4);
+    GST_LOG_OBJECT (qtdemux, "stsd type:          %" GST_FOURCC_FORMAT,
+        GST_FOURCC_ARGS (fourcc));
+
+    if (!fourcc_node)
+      fourcc_node = qtdemux_tree_get_child_by_type (stsd, fourcc);
+    else {
+      fourcc_node = g_node_next_sibling (fourcc_node);
+      /* TODO check that the type is of the same type */
+    }
+
+    if (!fourcc_node) {
+      GST_ERROR_OBJECT (qtdemux, "can not find a node for fourcc %"
+          GST_FOURCC_FORMAT " skipping this stsd entry",
+          GST_FOURCC_ARGS (fourcc));
+      goto next;
+    }
+
+    /* ok, we are ready to create a new stream and try to parse it */
+    stream = g_new0 (QtDemuxStream, 1);
+    /* first copy the common information */
+    memcpy (stream, trackinfo, sizeof (QtDemuxStream));
+    /* set the description index */
+    stream->description_idx = i + 1;
+
+    if (!qtdemux_parse_stsd_entry (qtdemux, stsd_data, entry_len, fourcc_node,
+            fourcc, stream)) {
+      GST_WARNING_OBJECT (qtdemux, "Parsing of stsd entry failed");
+      g_free (stream);
+      goto next;
+    }
+
+    qtdemux->streams[qtdemux->n_streams] = stream;
+    qtdemux->n_streams++;
+    GST_DEBUG_OBJECT (qtdemux, "n_streams is now %d", qtdemux->n_streams);
+
+  next:
+    stsd_data += entry_len;
+    len -= entry_len;
+  }
+
+  return TRUE;
+
+/* ERRORS */
+corrupt_file:
+  {
+    GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
+        (_("This file is corrupt and cannot be played.")), (NULL));
+    return FALSE;
   }
 too_many_streams:
   {
@@ -7572,6 +7992,179 @@
   }
 }
 
+/* parse the traks.
+ * With each track we associate a new QtDemuxStream that contains all the info
+ * about the trak.
+ * traks that do not decode to something (like strm traks) will not have a pad.
+ */
+static gboolean
+qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
+{
+  GstByteReader tkhd;
+  GNode *mdia;
+  GNode *mdhd;
+  GNode *hdlr;
+  GNode *minf;
+  GNode *stbl;
+  GNode *stsd;
+  QtDemuxStream *stream;
+  guint16 lang_code;            /* quicktime lang code or packed iso code */
+  guint32 version;
+  guint32 tkhd_flags = 0;
+  guint8 tkhd_version = 0;
+  guint value_size, len;
+
+  stream = g_new0 (QtDemuxStream, 1);
+  /* new streams always need a discont */
+  stream->discont = TRUE;
+  /* we enable clipping for raw audio/video streams */
+  stream->need_clip = FALSE;
+  stream->need_process = FALSE;
+  stream->segment_index = -1;
+  stream->time_position = 0;
+  stream->sample_index = -1;
+  stream->last_ret = GST_FLOW_OK;
+
+  if (!qtdemux_tree_get_child_by_type_full (trak, FOURCC_tkhd, &tkhd)
+      || !gst_byte_reader_get_uint8 (&tkhd, &tkhd_version)
+      || !gst_byte_reader_get_uint24_be (&tkhd, &tkhd_flags))
+    goto corrupt_file;
+
+  /* pick between 64 or 32 bits */
+  value_size = tkhd_version == 1 ? 8 : 4;
+  if (!gst_byte_reader_skip (&tkhd, value_size * 2) ||
+      !gst_byte_reader_get_uint32_be (&tkhd, &stream->track_id))
+    goto corrupt_file;
+
+  GST_LOG_OBJECT (qtdemux, "track[tkhd] version/flags/id: 0x%02x/%06x/%u",
+      tkhd_version, tkhd_flags, stream->track_id);
+
+  if (!(mdia = qtdemux_tree_get_child_by_type (trak, FOURCC_mdia)))
+    goto corrupt_file;
+
+  if (!(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mdhd))) {
+    /* be nice for some crooked mjp2 files that use mhdr for mdhd */
+    if (qtdemux->major_brand != FOURCC_mjp2 ||
+        !(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mhdr)))
+      goto corrupt_file;
+  }
+
+  len = QT_UINT32 ((guint8 *) mdhd->data);
+  version = QT_UINT32 ((guint8 *) mdhd->data + 8);
+  GST_LOG_OBJECT (qtdemux, "track version/flags: %08x", version);
+  if (version == 0x01000000) {
+    if (len < 38)
+      goto corrupt_file;
+    stream->timescale = QT_UINT32 ((guint8 *) mdhd->data + 28);
+    stream->duration = QT_UINT64 ((guint8 *) mdhd->data + 32);
+    lang_code = QT_UINT16 ((guint8 *) mdhd->data + 36);
+  } else {
+    if (len < 30)
+      goto corrupt_file;
+    stream->timescale = QT_UINT32 ((guint8 *) mdhd->data + 20);
+    stream->duration = QT_UINT32 ((guint8 *) mdhd->data + 24);
+    lang_code = QT_UINT16 ((guint8 *) mdhd->data + 28);
+  }
+
+  if (lang_code < 0x800) {
+    qtdemux_lang_map_qt_code_to_iso (stream->lang_id, lang_code);
+  } else {
+    stream->lang_id[0] = 0x60 + ((lang_code >> 10) & 0x1F);
+    stream->lang_id[1] = 0x60 + ((lang_code >> 5) & 0x1F);
+    stream->lang_id[2] = 0x60 + (lang_code & 0x1F);
+    stream->lang_id[3] = 0;
+  }
+
+  GST_LOG_OBJECT (qtdemux, "track timescale: %" G_GUINT32_FORMAT,
+      stream->timescale);
+  GST_LOG_OBJECT (qtdemux, "track duration: %" G_GUINT64_FORMAT,
+      stream->duration);
+  GST_LOG_OBJECT (qtdemux, "track language code/id: 0x%04x/%s",
+      lang_code, stream->lang_id);
+
+  if (G_UNLIKELY (stream->timescale == 0 || qtdemux->timescale == 0))
+    goto corrupt_file;
+
+  /* fragmented files may have bogus duration in moov */
+  if (!qtdemux->fragmented &&
+      qtdemux->duration != G_MAXINT64 && stream->duration != G_MAXINT32) {
+    guint64 tdur1, tdur2;
+
+    /* don't overflow */
+    tdur1 = stream->timescale * (guint64) qtdemux->duration;
+    tdur2 = qtdemux->timescale * (guint64) stream->duration;
+
+    /* HACK:
+     * some of those trailers, nowadays, have prologue images that are
+     * themselves vide tracks as well. I haven't really found a way to
+     * identify those yet, except for just looking at their duration. */
+    if (tdur1 != 0 && (tdur2 * 10 / tdur1) < 2) {
+      GST_WARNING_OBJECT (qtdemux,
+          "Track shorter than 20%% (%" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT
+          " vs. %" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT ") of the stream "
+          "found, assuming preview image or something; skipping track",
+          stream->duration, stream->timescale, qtdemux->duration,
+          qtdemux->timescale);
+      return TRUE;
+    }
+  }
+
+  if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
+    goto corrupt_file;
+
+  GST_LOG_OBJECT (qtdemux, "track type: %" GST_FOURCC_FORMAT,
+      GST_FOURCC_ARGS (QT_FOURCC ((guint8 *) hdlr->data + 12)));
+
+  len = QT_UINT32 ((guint8 *) hdlr->data);
+  if (len >= 20)
+    stream->subtype = QT_FOURCC ((guint8 *) hdlr->data + 16);
+  GST_LOG_OBJECT (qtdemux, "track subtype: %" GST_FOURCC_FORMAT,
+      GST_FOURCC_ARGS (stream->subtype));
+
+  if (stream->subtype == FOURCC_vide) {
+    guint32 w = 0, h = 0;
+
+    stream->sampled = TRUE;
+
+    /* version 1 uses some 64-bit ints */
+    if (!gst_byte_reader_skip (&tkhd, 56 + value_size)
+        || !gst_byte_reader_get_uint32_be (&tkhd, &w)
+        || !gst_byte_reader_get_uint32_be (&tkhd, &h))
+      goto corrupt_file;
+
+    stream->display_width = w >> 16;
+    stream->display_height = h >> 16;
+  }
+
+  if (!(minf = qtdemux_tree_get_child_by_type (mdia, FOURCC_minf)))
+    goto corrupt_file;
+
+  if (!(stbl = qtdemux_tree_get_child_by_type (minf, FOURCC_stbl)))
+    goto corrupt_file;
+
+  /* parse stsd */
+  if (!(stsd = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsd)))
+    goto corrupt_file;
+
+  /* stsd should at least have one entry */
+  if (!qtdemux_parse_stsd (qtdemux, stsd, stream))
+    goto corrupt_file;
+
+  /* finally free the temporary stream */
+  g_free (stream);
+
+  return TRUE;
+
+/* ERRORS */
+corrupt_file:
+  {
+    GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
+        (_("This file is corrupt and cannot be played.")), (NULL));
+    g_free (stream);
+    return FALSE;
+  }
+}
+
 /* If we can estimate the overall bitrate, and don't have information about the
  * stream bitrate for exactly one stream, this guesses the stream bitrate as
  * the overall bitrate minus the sum of the bitrates of all other streams. This
@@ -7680,8 +8273,9 @@
     GArray *durations;
     GstTagList *list;
 
-    GST_DEBUG_OBJECT (qtdemux, "stream %d, id %d, fourcc %" GST_FOURCC_FORMAT,
-        i, stream->track_id, GST_FOURCC_ARGS (stream->fourcc));
+    GST_DEBUG_OBJECT (qtdemux, "stream %d, id %d, idx %d, fourcc %"
+        GST_FOURCC_FORMAT, i, stream->track_id, stream->description_idx,
+        GST_FOURCC_ARGS (stream->fourcc));
 
     if (qtdemux->fragmented) {
       /* need all moov samples first */
@@ -7699,10 +8293,12 @@
     if (ret != GST_FLOW_ERROR)
       ret = GST_FLOW_OK;
 
-    /* in pull mode, we should have parsed some sample info by now;
-     * and quite some code will not handle no samples.
-     * in push mode, we'll just have to deal with it */
-    if (G_UNLIKELY (qtdemux->pullbased && !stream->n_samples)) {
+    /* in pull mode, we expose the streams whenever we are ready to parse
+     * movie data. in push mode we expose whenever we are about to send
+     * the new segment. In both cases we should have already parsed a moof
+     * that describes the samples or the stbl
+     */
+    if (G_UNLIKELY (!stream->n_samples)) {
       GST_DEBUG_OBJECT (qtdemux, "no samples for stream; discarding");
       gst_qtdemux_stream_free (qtdemux, stream);
       memmove (&(qtdemux->streams[i]), &(qtdemux->streams[i + 1]),
diff -urN a/gst/isomp4/qtdemux_fourcc.h b/gst/isomp4/qtdemux_fourcc.h
--- a/gst/isomp4/qtdemux_fourcc.h	2013-05-08 21:02:30.000000000 +0200
+++ b/gst/isomp4/qtdemux_fourcc.h	2013-05-09 15:23:51.486458564 +0200
@@ -238,6 +238,21 @@
 /* MPEG DASH */
 #define FOURCC_tfdt     GST_MAKE_FOURCC('t','f','d','t')
 
+#define FOURCC_encv     GST_MAKE_FOURCC('e','n','c','v')
+#define FOURCC_enca     GST_MAKE_FOURCC('e','n','c','a')
+#define FOURCC_sinf     GST_MAKE_FOURCC('s','i','n','f')
+#define FOURCC_schm     GST_MAKE_FOURCC('s','c','h','m')
+#define FOURCC_schi     GST_MAKE_FOURCC('s','c','h','i')
+
+/* ISO/IEC 23001-7 */
+#define FOURCC_cenc     GST_MAKE_FOURCC('c','e','n','c')
+#define FOURCC_senc     GST_MAKE_FOURCC('s','e','n','c')
+
+#define FOURCC_tenc     GST_MAKE_FOURCC('t','e','n','c')
+
+#define FOURCC_pssh     GST_MAKE_FOURCC('p','s','s','h')
+#define FOURCC_piff     GST_MAKE_FOURCC('p','i','f','f')
+
 G_END_DECLS
 
 #endif /* __GST_QTDEMUX_FOURCC_H__ */
diff -urN a/gst/isomp4/qtdemux.h b/gst/isomp4/qtdemux.h
--- a/gst/isomp4/qtdemux.h	2013-05-08 21:02:30.000000000 +0200
+++ b/gst/isomp4/qtdemux.h	2013-05-09 15:23:51.486458564 +0200
@@ -116,6 +116,10 @@
 
 struct _GstQTDemuxClass {
   GstElementClass parent_class;
+  void (*cenc_senc) (GstQTDemux * demux, guint32 track_id, GstBuffer * senc);
+  void (*cenc_tenc) (GstQTDemux * demux, guint32 track_id, GstBuffer * tenc);
+  void (*pssh) (GstQTDemux * demux, GstBuffer * pssh);
+  GstBuffer * (*decrypt) (GstQTDemux * demux, guint32 track_id, GstBuffer *buff, guint32 sample_index);
 };
 
 GType gst_qtdemux_get_type (void);
diff -urN a/gst/isomp4/qtdemux_types.c b/gst/isomp4/qtdemux_types.c
--- a/gst/isomp4/qtdemux_types.c	2013-05-08 21:02:30.000000000 +0200
+++ b/gst/isomp4/qtdemux_types.c	2013-05-09 15:23:51.450458563 +0200
@@ -172,6 +172,10 @@
   {FOURCC_ovc1, "ovc1", 0},
   {FOURCC_owma, "owma", 0},
   {FOURCC_tfdt, "Track fragment decode time", 0, qtdemux_dump_tfdt},
+  {FOURCC_frma, "frma", 0},
+  {FOURCC_sinf, "sinf", QT_FLAG_CONTAINER,},
+  {FOURCC_schm, "schm", 0},
+  {FOURCC_schi, "schi", QT_FLAG_CONTAINER,},
   {0, "unknown", 0,},
 };
 
diff -urN a/gst/isomp4/qtdemux_types.h b/gst/isomp4/qtdemux_types.h
--- a/gst/isomp4/qtdemux_types.h	2013-05-08 21:02:30.000000000 +0200
+++ b/gst/isomp4/qtdemux_types.h	2013-05-09 15:23:51.502458561 +0200
@@ -62,7 +62,8 @@
   TF_DEFAULT_SAMPLE_DURATION  = 0x000008,   /* default-sample-duration-present */
   TF_DEFAULT_SAMPLE_SIZE      = 0x000010,   /* default-sample-size-present */
   TF_DEFAULT_SAMPLE_FLAGS     = 0x000020,   /* default-sample-flags-present */
-  TF_DURATION_IS_EMPTY        = 0x100000    /* duration-is-empty */
+  TF_DURATION_IS_EMPTY        = 0x100000,   /* duration-is-empty */
+  TF_DEFAULT_BASE_IS_MOOF     = 0x020000    /* default-base-is-moof */
 };
 
 enum TrFlags
